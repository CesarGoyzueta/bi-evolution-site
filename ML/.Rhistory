} else {
stop("No encuentro hurst_new.R en el directorio de trabajo")
}
if (file.exists("fbmSim.R")) {
source("fbmSim.R")  # simulador auxiliar
}
# --- CÃ¡lculo del exponente de Hurst ---
HURST <- rsFit(rend, doplot = TRUE)  # rend = rendimientos limpios
H_est <- HURST@hurst$diag[2,1]       # valor estimado de H
H_se  <- HURST@hurst$diag[2,2]       # error estÃ¡ndar
t_h   <- (H_est - 0.5) / H_se        # estadÃ­stico t
p_h   <- 2 * pt(abs(t_h), df = length(HURST@fit$wt) - 2, lower.tail = FALSE)
cat("\n[4] EXPONENTE DE HURST (RS)\n")
# 1. Intentamos usar la versiÃ³n del profe (hurst_new.R)
tengo_rsfit <- FALSE
if (file.exists("hurst_new.R")) {
source("hurst_new.R")   # define rsFit()
tengo_rsfit <- TRUE
}
# 2. Si no estÃ¡ hurst_new.R, usamos pracma::hurstexp()
if (!tengo_rsfit) {
if (!require(pracma)) install.packages("pracma")
library(pracma)
cat("No se encontrÃ³ 'hurst_new.R', uso hurstexp() de 'pracma'.\n")
}
# --- CÃ¡lculo de H segÃºn lo disponible ---
if (tengo_rsfit) {
# -----------------------------------------
# VersiÃ³n con rsFit() (la del material original)
# -----------------------------------------
HURST <- rsFit(rend, doplot = TRUE)   # 'rend' = rendimientos limpios
H_est <- HURST@hurst$diag[2,1]        # estimaciÃ³n de H
H_se  <- HURST@hurst$diag[2,2]        # error estÃ¡ndar
# estadÃ­stico t para probar H = 0.5
t_h   <- (H_est - 0.5) / H_se
p_h   <- 2 * pt(abs(t_h), df = length(HURST@fit$wt) - 2, lower.tail = FALSE)
cat(sprintf("H (rsFit) = %.4f, t = %.4f, p = %.4f\n", H_est, t_h, p_h))
} else {
# -----------------------------------------
# VersiÃ³n con hurstexp() (muy aceptable)
# -----------------------------------------
hobj  <- hurstexp(as.numeric(rend), display = FALSE)
# hurstexp da varios estimadores; el mÃ¡s parecido al R/S clÃ¡sico es $HurstRS
H_est <- hobj$HurstRS
# acÃ¡ no tenemos directamente el error estÃ¡ndar, asÃ­ que sÃ³lo reportamos H
cat(sprintf("H (hurstexp) = %.4f\n", H_est))
# InterpretaciÃ³n bÃ¡sica sin t-test:
if (H_est > 0.55) {
cat("InterpretaciÃ³n: H > 0.5 â†’ hay/podrÃ­a haber persistencia (tendencias dÃ©biles).\n")
} else if (H_est < 0.45) {
cat("InterpretaciÃ³n: H < 0.5 â†’ hay/podrÃ­a haber antipersistencia (reversiÃ³n a la media).\n")
} else {
cat("InterpretaciÃ³n: H â‰ˆ 0.5 â†’ comportamiento cercano a paseo aleatorio / mercado eficiente.\n")
}
}
HURST
# 1. Intentamos usar la versiÃ³n del profe (hurst_new.R)
tengo_rsfit <- FALSE
if (file.exists("hurst_new.R")) {
source("hurst_new.R")   # define rsFit()
tengo_rsfit <- TRUE
}
# 2. Si no estÃ¡ hurst_new.R, usamos pracma::hurstexp()
if (!tengo_rsfit) {
if (!require(pracma)) install.packages("pracma")
library(pracma)
cat("No se encontrÃ³ 'hurst_new.R', uso hurstexp() de 'pracma'.\n")
}
install.packages("pracma")
library(pracma)
# --- CÃ¡lculo de H segÃºn lo disponible ---
if (tengo_rsfit) {
# -----------------------------------------
# VersiÃ³n con rsFit() (la del material original)
# -----------------------------------------
HURST <- rsFit(rend, doplot = TRUE)   # 'rend' = rendimientos limpios
H_est <- HURST@hurst$diag[2,1]        # estimaciÃ³n de H
H_se  <- HURST@hurst$diag[2,2]        # error estÃ¡ndar
# estadÃ­stico t para probar H = 0.5
t_h   <- (H_est - 0.5) / H_se
p_h   <- 2 * pt(abs(t_h), df = length(HURST@fit$wt) - 2, lower.tail = FALSE)
cat(sprintf("H (rsFit) = %.4f, t = %.4f, p = %.4f\n", H_est, t_h, p_h))
} else {
# -----------------------------------------
# VersiÃ³n con hurstexp() (muy aceptable)
# -----------------------------------------
hobj  <- hurstexp(as.numeric(rend), display = FALSE)
# hurstexp da varios estimadores; el mÃ¡s parecido al R/S clÃ¡sico es $HurstRS
H_est <- hobj$HurstRS
# acÃ¡ no tenemos directamente el error estÃ¡ndar, asÃ­ que sÃ³lo reportamos H
cat(sprintf("H (hurstexp) = %.4f\n", H_est))
# InterpretaciÃ³n bÃ¡sica sin t-test:
if (H_est > 0.55) {
cat("InterpretaciÃ³n: H > 0.5 â†’ hay/podrÃ­a haber persistencia (tendencias dÃ©biles).\n")
} else if (H_est < 0.45) {
cat("InterpretaciÃ³n: H < 0.5 â†’ hay/podrÃ­a haber antipersistencia (reversiÃ³n a la media).\n")
} else {
cat("InterpretaciÃ³n: H â‰ˆ 0.5 â†’ comportamiento cercano a paseo aleatorio / mercado eficiente.\n")
}
}
# --- CÃ¡lculo de H segÃºn lo disponible ---
if (tengo_rsfit) {
# -----------------------------------------
# VersiÃ³n con rsFit() (la del material original)
# -----------------------------------------
HURST <- rsFit(rend, doplot = TRUE)   # 'rend' = rendimientos limpios
H_est <- HURST@hurst$diag[2,1]        # estimaciÃ³n de H
H_se  <- HURST@hurst$diag[2,2]        # error estÃ¡ndar
# estadÃ­stico t para probar H = 0.5
t_h   <- (H_est - 0.5) / H_se
p_h   <- 2 * pt(abs(t_h), df = length(HURST@fit$wt) - 2, lower.tail = FALSE)
cat(sprintf("H (rsFit) = %.4f, t = %.4f, p = %.4f\n", H_est, t_h, p_h))
} else {
# -----------------------------------------
# VersiÃ³n con hurstexp() (muy aceptable)
# -----------------------------------------
hobj  <- hurstexp(as.numeric(rend), display = FALSE)
# hurstexp da varios estimadores; el mÃ¡s parecido al R/S clÃ¡sico es $HurstRS
H_est <- hobj$HurstRS
# acÃ¡ no tenemos directamente el error estÃ¡ndar, asÃ­ que sÃ³lo reportamos H
cat(sprintf("H (hurstexp) = %.4f\n", H_est))
# InterpretaciÃ³n bÃ¡sica sin t-test:
if (H_est > 0.55) {
cat("InterpretaciÃ³n: H > 0.5 â†’ hay/podrÃ­a haber persistencia (tendencias dÃ©biles).\n")
} else if (H_est < 0.45) {
cat("InterpretaciÃ³n: H < 0.5 â†’ hay/podrÃ­a haber antipersistencia (reversiÃ³n a la media).\n")
} else {
cat("InterpretaciÃ³n: H â‰ˆ 0.5 â†’ comportamiento cercano a paseo aleatorio / mercado eficiente.\n")
}
}
hurstexp(as.numeric(rend), display = FALSE)
1. Intentamos usar la versiÃ³n del material (rsFit)
# 1. Intentamos usar la versiÃ³n del material (rsFit)
tengo_rsfit <- FALSE
if (file.exists("hurst_new.R")) {
source("hurst_new.R")   # aquÃ­ viene rsFit()
tengo_rsfit <- TRUE
}
# 2. Si no existe hurst_new.R usamos pracma
if (!tengo_rsfit) {
if (!require(pracma)) install.packages("pracma")
library(pracma)
cat("No se encontrÃ³ 'hurst_new.R', uso hurstexp() de 'pracma'.\n")
}
if (tengo_rsfit) {
# -----------------------------
# OpciÃ³n A: usar rsFit()
# -----------------------------
HURST <- rsFit(rend, doplot = TRUE)   # 'rend' = rendimientos limpios
H_est <- HURST@hurst$diag[2,1]        # estimaciÃ³n de H
H_se  <- HURST@hurst$diag[2,2]        # error estÃ¡ndar
t_h   <- (H_est - 0.5) / H_se         # estadÃ­stico t para H=0.5
p_h   <- 2 * pt(abs(t_h), df = length(HURST@fit$wt) - 2, lower.tail = FALSE)
cat(sprintf("H (rsFit) = %.4f, t = %.4f, p = %.4f\n", H_est, t_h, p_h))
# InterpretaciÃ³n rÃ¡pida:
# p_h grande â†’ NO rechazo H=0.5 â†’ compatible con mercado eficiente
# p_h chico  â†’ rechazo H=0.5 â†’ hay memoria (persistencia o anti-)
} else {
# -----------------------------
# OpciÃ³n B: usar hurstexp()
# -----------------------------
hobj <- hurstexp(as.numeric(rend), display = FALSE)
# hurstexp devuelve varios estimadores:
# hobj$Hs  â†’ versiÃ³n tipo "scaled rescaled range"
# hobj$Hrs â†’ versiÃ³n R/S clÃ¡sica (esta es la que mÃ¡s se parece a lo que pide la tarea)
# hobj$He, hobj$Hal, hobj$Ht â†’ otros mÃ©todos
H_est <- hobj$Hrs   # ðŸ‘ˆ esta es la clave: usar Hrs
cat(sprintf("H (hurstexp, mÃ©todo R/S) = %.4f\n", H_est))
# InterpretaciÃ³n bÃ¡sica sin t-test:
if (!is.na(H_est)) {
if (H_est > 0.55) {
cat("InterpretaciÃ³n: H > 0.5 â†’ hay/podrÃ­a haber persistencia (tendencias dÃ©biles).\n")
} else if (H_est < 0.45) {
cat("InterpretaciÃ³n: H < 0.5 â†’ hay/podrÃ­a haber antipersistencia (reversiÃ³n a la media).\n")
} else {
cat("InterpretaciÃ³n: H â‰ˆ 0.5 â†’ comportamiento cercano a paseo aleatorio / mercado eficiente.\n")
}
} else {
cat("No se pudo calcular H correctamente.\n")
}
}
#==============================================#
# 5) Test BDS de independencia (rendimientos)
#==============================================#
cat("\n[5] TEST BDS (i.i.d.)\n")
sd_r <- sd(rend)
cat(sprintf("sd(r) = %.6f\n", sd_r))
# Embedding dimension m (comÃºn: 8â€“10). Usamos 8.
print(bds.test(as.numeric(rend), m = 8))   # H0: i.i.d.
#==============================================#
# 6) Normalidad: bandas Â±2Ïƒ, % fuera; histograma + densidad empÃ­rica y N(0,1)
#==============================================#
cat("\n[6] NORMALIDAD (bandas y densidades)\n")
# Limpieza mÃ­nima por si acaso
r_clean <- as.numeric(rend)
r_clean <- r_clean[is.finite(r_clean)]
# Media y desviaciÃ³n
m_r <- mean(r_clean); s_r <- sd(r_clean)
# Ãndices fuera de Â±2Ïƒ
idx_out <- which(abs(r_clean - m_r) > 2*s_r)
n_out   <- length(idx_out)
n_tot   <- length(r_clean)
pct_out <- 100 * n_out / n_tot
# Referencia teÃ³rica bajo N(0,1): ~4.55% fuera de Â±2Ïƒ
pct_theo <- 100 * (2 * (1 - pnorm(2)))  # â‰ˆ 4.55%
cat(sprintf("Puntos fuera de Â±2Ïƒ: %d / %d  (%.4f%%)\n", n_out, n_tot, pct_out))
cat(sprintf("Referencia teÃ³rica N(0,1): %.2f%% fuera de Â±2Ïƒ\n", pct_theo))
sd_r <- sd(rend)
cat(sprintf("sd(r) = %.6f\n", sd_r))
# Embedding dimension m (comÃºn: 8â€“10). Usamos 8.
print(bds.test(as.numeric(rend), m = 8))   # H0: i.i.d.
# Embedding dimension m (comÃºn: 8â€“10). Usamos 8.
# bds.test() a veces falla con m muy grande o series cortas,
# asÃ­ que probamos varias dimensiones (m) tÃ­picas: 2, 3 y 4.
# H0: la serie es i.i.d.
m_vals <- c(2, 3, 4)
for (m in m_vals) {
cat(sprintf("\n-- BDS con m = %d --\n", m))
bd <- bds.test(as.numeric(rend), m = m)
print(bd)
# InterpretaciÃ³n rÃ¡pida:
# p-value alto  -> NO rechazo H0 -> rendimientos compatibles con i.i.d.
# p-value bajo  -> rechazo H0     -> hay dependencia/no linealidad
}
# Normalidad: bandas Â±2Ïƒ e histograma
#
# Se grafica la serie de rendimientos junto con las bandas Â±2 desviaciones estÃ¡ndar alrededor de la media. En una distribuciÃ³n Normal N(0,1), se espera que aproximadamente el 4,55 % de las observaciones quede fuera de estas bandas. Por tanto, se calcula el porcentaje real de puntos fuera de Â±2Ïƒ y se compara con el valor teÃ³rico.
#
# InterpretaciÃ³n:
#   - Si el porcentaje observado es cercano a 4,5 %, los rendimientos son mÃ¡s parecidos a una distribuciÃ³n normal.
# - Si el porcentaje observado es claramente mayor (por ejemplo 8â€“10 %), la serie presenta colas gruesas (mÃ¡s extremos de los que predice la normal), lo que es tÃ­pico en series financieras.
#
# AdemÃ¡s, se estandarizan los rendimientos y se comparan la densidad empÃ­rica y la Normal N(0,1). Esto permite visualizar si hay exceso de curtosis (pico alto) o colas pesadas. Esta parte tambiÃ©n es requerida en la Tarea 1 â€“ Parte II.
install.packages("tseries")   # solo la 1Âª vez
library(tseries)              # SIEMPRE en la sesiÃ³n donde vas a usar bds.test
#==============================================#
cat("\n[6] NORMALIDAD (bandas y densidades)\n")
# Limpieza mÃ­nima por si acaso
r_clean <- as.numeric(rend)
r_clean <- r_clean[is.finite(r_clean)]
# Media y desviaciÃ³n
m_r <- mean(r_clean); s_r <- sd(r_clean)
# Ãndices fuera de Â±2Ïƒ
idx_out <- which(abs(r_clean - m_r) > 2*s_r)
n_out   <- length(idx_out)
n_tot   <- length(r_clean)
pct_out <- 100 * n_out / n_tot
# Referencia teÃ³rica bajo N(0,1): ~4.55% fuera de Â±2Ïƒ
pct_theo <- 100 * (2 * (1 - pnorm(2)))  # â‰ˆ 4.55%
cat("\n[5] TEST BDS (i.i.d.)\n")
sd_r <- sd(rend)
cat(sprintf("sd(r) = %.6f\n", sd_r))
# Embedding dimension m (comÃºn: 8â€“10). Usamos 8.
# bds.test() a veces falla con m muy grande o series cortas,
# asÃ­ que probamos varias dimensiones (m) tÃ­picas: 2, 3 y 4.
# H0: la serie es i.i.d.
m_vals <- c(2, 3, 4)
for (m in m_vals) {
cat(sprintf("\n-- BDS con m = %d --\n", m))
bd <- bds.test(as.numeric(rend), m = m)
print(bd)
# InterpretaciÃ³n rÃ¡pida:
# p-value alto  -> NO rechazo H0 -> rendimientos compatibles con i.i.d.
# p-value bajo  -> rechazo H0     -> hay dependencia/no linealidad
}
#==============================================#
# 5) Test BDS de independencia (rendimientos)
#==============================================#
install.packages("tseries")   # solo la 1Âª vez
cat("\n[5] TEST BDS (i.i.d.)\n")
sd_r <- sd(rend)
cat(sprintf("sd(r) = %.6f\n", sd_r))
# Embedding dimension m (comÃºn: 8â€“10). Usamos 8.
# bds.test() a veces falla con m muy grande o series cortas,
# asÃ­ que probamos varias dimensiones (m) tÃ­picas: 2, 3 y 4.
# H0: la serie es i.i.d.
m_vals <- c(2, 3, 4)
for (m in m_vals) {
cat(sprintf("\n-- BDS con m = %d --\n", m))
bd <- bds.test(as.numeric(rend), m = m)
print(bd)
# InterpretaciÃ³n rÃ¡pida:
# p-value alto  -> NO rechazo H0 -> rendimientos compatibles con i.i.d.
# p-value bajo  -> rechazo H0     -> hay dependencia/no linealidad
}
# Embedding dimension m (comÃºn: 8â€“10). Usamos 8.
# bds.test() a veces falla con m muy grande o series cortas,
# asÃ­ que probamos varias dimensiones (m) tÃ­picas: 2, 3 y 4.
# H0: la serie es i.i.d.
m_vals <- c(2, 3, 4)
for (m in m_vals) {
cat(sprintf("\n-- BDS con m = %d --\n", m))
bd <- bds.test(as.numeric(rend), m = m)
print(bd)
# InterpretaciÃ³n rÃ¡pida:
# p-value alto  -> NO rechazo H0 -> rendimientos compatibles con i.i.d.
# p-value bajo  -> rechazo H0     -> hay dependencia/no linealidad
}
#==============================================#
# 5) Test BDS de independencia (rendimientos)
#==============================================#
#install.packages("tseries")   # solo la 1Âª vez
library(tseries)              # SIEMPRE en la sesiÃ³n donde vas a usar bds.test
cat("\n[5] TEST BDS (i.i.d.)\n")
sd_r <- sd(rend)
cat(sprintf("sd(r) = %.6f\n", sd_r))
# Embedding dimension m (comÃºn: 8â€“10). Usamos 8.
# bds.test() a veces falla con m muy grande o series cortas,
# asÃ­ que probamos varias dimensiones (m) tÃ­picas: 2, 3 y 4.
# H0: la serie es i.i.d.
m_vals <- c(2, 3, 4)
for (m in m_vals) {
cat(sprintf("\n-- BDS con m = %d --\n", m))
bd <- bds.test(as.numeric(rend), m = m)
print(bd)
# InterpretaciÃ³n rÃ¡pida:
# p-value alto  -> NO rechazo H0 -> rendimientos compatibles con i.i.d.
# p-value bajo  -> rechazo H0     -> hay dependencia/no linealidad
}
#==============================================#
cat("\n[6] NORMALIDAD (bandas y densidades)\n")
# Limpieza mÃ­nima por si acaso
r_clean <- as.numeric(rend)
r_clean <- r_clean[is.finite(r_clean)]
# Media y desviaciÃ³n
m_r <- mean(r_clean); s_r <- sd(r_clean)
# Ãndices fuera de Â±2Ïƒ
idx_out <- which(abs(r_clean - m_r) > 2*s_r)
n_out   <- length(idx_out)
n_tot   <- length(r_clean)
pct_out <- 100 * n_out / n_tot
# Referencia teÃ³rica bajo N(0,1): ~4.55% fuera de Â±2Ïƒ
pct_theo <- 100 * (2 * (1 - pnorm(2)))  # â‰ˆ 4.55%
cat(sprintf("Puntos fuera de Â±2Ïƒ: %d / %d  (%.4f%%)\n", n_out, n_tot, pct_out))
cat(sprintf("Referencia teÃ³rica N(0,1): %.2f%% fuera de Â±2Ïƒ\n", pct_theo))
# ---- GrÃ¡fico de la serie con bandas y puntos fuera de Â±2Ïƒ destacados ----
png("figs/06_rend_bandas_2sigma.png", width = 1100, height = 460)
dev.off()
# ---- GrÃ¡fico de la serie con bandas y puntos fuera de Â±2Ïƒ destacados ----
#png("figs/06_rend_bandas_2sigma.png", width = 1100, height = 460)
plot(r_clean, type="l",
main = expression(paste("Rendimientos con bandas  ", "\u00B1","2",sigma)),
xlab = "Tiempo", ylab = expression(r[t]))
abline(h = m_r, lty = 3)
abline(h = m_r + 2*s_r, lty = 2, col = "red")
abline(h = m_r - 2*s_r, lty = 2, col = "red")
# Puntos fuera de Â±2Ïƒ
if (n_out > 0) points(idx_out, r_clean[idx_out], col = "red", pch = 19)
legend("topleft", bty = "n",
legend = c(
sprintf("Fuera Â±2Ïƒ: %d / %d (%.2f%%)", n_out, n_tot, pct_out),
sprintf("TeÃ³rico N(0,1): %.2f%%", pct_theo)
))
# Referencia teÃ³rica bajo N(0,1): ~4.55% fuera de Â±2Ïƒ
pct_theo <- 100 * (2 * (1 - pnorm(2)))  # â‰ˆ 4.55%
cat(sprintf("Puntos fuera de Â±2Ïƒ: %d / %d  (%.4f%%)\n", n_out, n_tot, pct_out))
cat(sprintf("Referencia teÃ³rica N(0,1): %.2f%% fuera de Â±2Ïƒ\n", pct_theo))
# ---- Estandarizar rendimientos para comparar con N(0,1) ----
z <- (r_clean - m_r) / s_r
#png("figs/06_hist_dens_normal.png", width = 1100, height = 460)
hist(z, breaks = "FD", freq = FALSE,
main = sprintf("z = (r - media)/sd | EmpÃ­rico vs N(0,1)\nFuera Â±2Ïƒ: %.2f%% (TeÃ³rico: %.2f%%)",
pct_out, pct_theo),
xlab = "z", ylab = "Densidad")
lines(density(z), lwd = 2)                 # densidad empÃ­rica
curve(dnorm(x, 0, 1), add = TRUE, lwd = 2, lty = 2)  # N(0,1) teÃ³rica
legend("topright", bty = "n",
legend = c("Densidad empÃ­rica", "N(0,1)"),
lty = c(1, 2), lwd = c(2, 2))
# Paquetes (aÃ±ado pracma para Hurst sin source externos)
if(!require(pracma)) install.packages("pracma")
library(pracma)
#==============================================#
# 2) ACF/PACF de rendimientos + Ljungâ€“Box para p = 1,2,3,4,5
#   (versiÃ³n robusta: limpia NAs/Inf antes de los tests)
#==============================================#
#
# â€¢ ACF(r): mira si los rendimientos estÃ¡n correlacionados con sus rezagos.
# - H0 (Ljungâ€“Box): no hay autocorrelaciÃ³n conjunta hasta el lag k.
# - Si los p-valores son bajos â†’ hay dependencia en media â†’ modelo ARMA tiene sentido.
#
# â€¢ PACF(r): igual que ACF pero â€œlimpiaâ€ el efecto de rezagos intermedios.
# - Picos en PACF â†’ orden AR.
# - Picos en ACF â†’ orden MA.
#
# â€¢ ACF(rÂ²): se aplica sobre los rendimientos al cuadrado.
# - Sirve para ver SI LA VARIANZA ESTÃ CORRELACIONADA EN EL TIEMPO.
# - Si hay picos en ACF(rÂ²) â†’ hay clustering de volatilidad â†’ despuÃ©s se justifica GARCH.
cat("\n[2] ACF/PACF y Ljung-Box (rendimientos)\n")
# --- Limpieza mÃ­nima por si hubiera NA/NaN/Inf en rend ---
r_clean <- as.numeric(rend)          # asegura vector numÃ©rico
r_clean <- r_clean[is.finite(r_clean)]  # elimina NA, NaN, +Inf, -Inf
# --- GrÃ¡fico ACF/PACF de rendimientos ---
dir.create("figs", showWarnings = FALSE)
#png("figs/02_ACF_PACF_rend.png", width = 1100, height = 500)
par(mfrow = c(1, 2))
Acf(r_clean, lag.max = 40, ylim = c(-0.05, 0.05), main = "ACF(r)",  na.action = na.omit)
library(tseries)
library(zoo)
library(outliers)
library(forecast)
# --- Limpieza mÃ­nima por si hubiera NA/NaN/Inf en rend ---
r_clean <- as.numeric(rend)          # asegura vector numÃ©rico
r_clean <- r_clean[is.finite(r_clean)]  # elimina NA, NaN, +Inf, -Inf
# --- GrÃ¡fico ACF/PACF de rendimientos ---
dir.create("figs", showWarnings = FALSE)
#png("figs/02_ACF_PACF_rend.png", width = 1100, height = 500)
par(mfrow = c(1, 2))
Acf(r_clean, lag.max = 40, ylim = c(-0.05, 0.05), main = "ACF(r)",  na.action = na.omit)
Pacf(r_clean, lag.max = 40, ylim =c(-0.05, 0.05), main = "PACF(r)", na.action = na.omit)
par(mfrow = c(1, 1))
#| include: false
# ============================================================================
# CONFIGURACIÃ“N INICIAL Y CARGA DE LIBRERÃAS
# ============================================================================
#
# EXCEPCIÃ“N: Lo correrÃ­as antes si:
#
# ðŸ”´ Drawdown >-10% (alerta crÃ­tica)
# ðŸ”´ Volatilidad >30% (pÃ¡nico de mercado)
# ðŸ“° Evento mayor (crisis, guerra, Fed inesperado)
# ðŸ“Š RESUMEN ULTRA-CORTO
# Â¿QuÃ©?Â¿CuÃ¡ndo?Â¿Para quÃ©?Ejecutar scriptCada 3 mesesActualizar allocaciÃ³nHTML generadoAl ejecutarLeer anÃ¡lisis completoCSV trading_weightsAl ejecutarComprar acciones en brokerOtros CSVsAl ejecutarGuardar histÃ³rico (opcional)
# Configurar mirror de CRAN
options(repos = c(CRAN = "https://cran.rstudio.com/"))
# Instalar TODOS los paquetes necesarios (solo una vez)
install.packages(c(
"quantmod", "PerformanceAnalytics", "PortfolioAnalytics",
"dplyr", "tidyr", "purrr", "ROI", "ROI.plugin.quadprog",
"ROI.plugin.glpk", "MASS", "ggplot2", "plotly", "patchwork",
"scales", "RColorBrewer", "kableExtra", "DT", "xts", "zoo",
"tseries", "forecast", "lubridate", "jsonlite"
))
# Si no hay errores, estÃ¡s listo âœ“
# LibrerÃ­as principales
library(quantmod)
library(PerformanceAnalytics)
library(PortfolioAnalytics)
library(dplyr)
library(tidyr)
library(purrr)
# OptimizaciÃ³n
library(ROI)
library(ROI.plugin.quadprog)
library(ROI.plugin.glpk)
library(MASS)
# VisualizaciÃ³n
library(ggplot2)
library(plotly)
library(patchwork)
library(scales)
library(RColorBrewer)
# Tablas y reportes
library(kableExtra)
library(DT)
# Series de tiempo
library(xts)
library(zoo)
library(tseries)
library(forecast)
# Utilidades
library(lubridate)
library(jsonlite)
# ConfiguraciÃ³n global
Sys.setenv(TZ = 'UTC')
options(
scipen = 999,
digits = 4,
warn = -1
)
# Colores profesionales
colors_portfolio <- c(
primary = "#2C3E50",
success = "#27AE60",
danger = "#E74C3C",
warning = "#F39C12",
info = "#3498DB",
tech = "#9B59B6",
finance = "#1ABC9C"
)
# ConfiguraciÃ³n de logging
log_file <- paste0("portfolio_log_", format(Sys.Date(), "%Y%m%d"), ".txt")
log_message <- function(msg, level = "INFO") {
timestamp <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")
log_entry <- sprintf("[%s] %s: %s\n", timestamp, level, msg)
cat(log_entry)
cat(log_entry, file = log_file, append = TRUE)
}
log_message("Iniciando anÃ¡lisis de portfolio profesional")
setwd("C:/Users/Cesar/OneDrive/Proyectos futuros/BI_Evolution/ML")
#| echo: false
#| warning: false
#| message: false
prospectos <- read_csv("C:/Users/Cesar/OneDrive/Proyectos futuros/BI_Evolution/ML/Cluster_analysis/prospectos.csv")
#| echo: false
#| warning: false
#| message: false
# Instalar paquetes SOLO la primera vez, despuÃ©s puedes comentarlo
# install.packages(c("readr", "dplyr", "clValid", "cluster", "factoextra", "dbscan", "tibble"))
library(readr)
library(dplyr)
library(clValid)
library(cluster)
library(factoextra)
library(dbscan)
library(tibble)
set.seed(123)
#| echo: false
#| warning: false
#| message: false
prospectos <- read_csv("C:/Users/Cesar/OneDrive/Proyectos futuros/BI_Evolution/ML/Cluster_analysis/prospectos.csv")
glimpse(prospectos)
