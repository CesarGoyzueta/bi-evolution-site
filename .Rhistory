eval_combo <- function(popsize, generations) {
set.seed(seed)
t0 <- proc.time()
out <- try(
generar_reporte_long_v2(
dinero_inicial = dinero_inicial,
ticker         = ticker,
years_back     = years_back,
split_train    = split_train,
popsize        = popsize,
generations    = generations,
preferir_abierta = preferir_abierta,
show_plot      = show_plot
),
silent = TRUE
)
elapsed <- as.numeric((proc.time() - t0)[3])
if (inherits(out, "try-error") || is.null(out)) {
return(dplyr::tibble(
ticker = ticker, popsize = popsize, generations = generations,
status = "FAIL", motivo = substr(as.character(out), 1, 160),
PnL = NA_real_, CAGR = NA_real_, Sharpe = NA_real_, MaxDD = NA_real_,
seconds = elapsed
))
}
dplyr::tibble(
ticker = ticker, popsize = popsize, generations = generations,
status = "OK", motivo = "",
PnL = as.numeric(out$ganancia),
CAGR = as.numeric(out$cagr),
Sharpe = as.numeric(out$sharpe),
MaxDD = as.numeric(out$mdd),
seconds = elapsed
)
}
# ---------- Correr la grilla (opcional en paralelo) ----------
grid <- expand.grid(popsize = pop_grid, generations = gen_grid, KEEP.OUT.ATTRS = FALSE)
if (parallel) {
if (!requireNamespace("future", quietly = TRUE) ||
!requireNamespace("furrr", quietly = TRUE)) {
warning("Paralelo requiere 'future' y 'furrr'; se usará modo secuencial.")
results <- purrr::pmap_dfr(grid, ~ eval_combo(..1, ..2))
} else {
future::plan(future::multisession, workers = workers)
on.exit(future::plan(future::sequential), add = TRUE)
results <- furrr::future_pmap_dfr(grid, ~ eval_combo(..1, ..2))
}
} else {
results <- purrr::pmap_dfr(grid, ~ eval_combo(..1, ..2))
}
results <- dplyr::arrange(results, dplyr::desc(PnL))
# ---------- Frontera eficiente (máx PnL, mín seconds) ----------
is_dominated <- function(i, X) {
any(X$seconds <= X$seconds[i] & X$PnL >= X$PnL[i] &
(X$seconds < X$seconds[i] | X$PnL > X$PnL[i]), na.rm = TRUE)
}
res_ok <- results %>% dplyr::filter(status == "OK")
pareto_idx <- if (nrow(res_ok) > 0) which(!vapply(seq_len(nrow(res_ok)), is_dominated, logical(1), X = res_ok)) else integer(0)
res_ok$pareto <- FALSE
if (length(pareto_idx)) res_ok$pareto[pareto_idx] <- TRUE
results <- results %>% left_join(res_ok %>% select(popsize, generations, pareto), by = c("popsize","generations"))
# ---------- Tabla DT ----------
dt <- datatable(
results %>%
mutate(CAGR = percent(CAGR, accuracy = 0.1),
MaxDD = percent(MaxDD, accuracy = 0.1),
seconds = round(seconds, 1),
pareto = ifelse(isTRUE(pareto), "Sí", "No")),
options = list(pageLength = min(30, nrow(results)),
language = list(url='//cdn.datatables.net/plug-ins/1.10.21/i18n/Spanish.json')),
caption = paste("Benchmark", ticker, "—", nrow(results), "combinaciones")
)
# ---------- Heatmap PnL ----------
heat_df <- results %>% filter(status == "OK") %>%
mutate(popsize = factor(popsize), generations = factor(generations))
heatmap <- plot_ly(
heat_df, x = ~generations, y = ~popsize, z = ~PnL, type = "heatmap",
hovertemplate = "Gen: %{x}<br>Pop: %{y}<br>PnL: $%{z:.0f}<extra></extra>"
) %>% layout(
title = paste0(ticker, " — PnL por (popsize, generations)"),
xaxis = list(title = "Generations"),
yaxis = list(title = "Popsize")
)
# ---------- Scatter tiempo vs PnL + frontera ----------
scatter <- plot_ly(
results %>% filter(status == "OK"),
x = ~seconds, y = ~PnL, type = "scatter", mode = "markers",
size = ~pmax(Sharpe, 0), color = ~MaxDD,
text = ~paste0("popsize=", popsize, " • gen=", generations,
"<br>Sharpe=", round(Sharpe, 2),
"<br>MaxDD=", percent(MaxDD, 0.1)),
hovertemplate = "Tiempo: %{x:.1f}s<br>PnL: $%{y:.0f}<br>%{text}<extra></extra>"
) %>% layout(
title = paste0(ticker, " — PnL vs Tiempo (tamaño=Sharpe, color=MaxDD)"),
xaxis = list(title = "Segundos"),
yaxis = list(title = "PnL ($)")
)
if (any(res_ok$pareto)) {
scatter <- scatter %>%
add_trace(
data = res_ok %>% filter(pareto),
x = ~seconds, y = ~PnL, type = "scatter", mode = "markers+lines",
marker = list(symbol = "diamond-open", size = 10),
name = "Frontera eficiente",
hovertemplate = "FRONTERA<br>Tiempo: %{x:.1f}s<br>PnL: $%{y:.0f}<extra></extra>"
)
}
list(
results = results,
table   = dt,
heatmap = heatmap,
scatter = scatter,
best_by_pnl = results %>% filter(status == "OK") %>% slice_max(PnL, n = 1, with_ties = FALSE),
pareto_set = res_ok %>% filter(pareto) %>% arrange(seconds, desc(PnL))
)
}
bench_nvda <- benchmark_nsga(
ticker = "EL",
years_back = 7,
pop_grid = c(24,36,48,60,72),
gen_grid = c(20,30,40,50),
parallel = FALSE  # pon TRUE si tienes 'future' y 'furrr'
)
## --- CONFIG PRINCIPAL ---
# =======================  BENCHMARK NSGA-II  =======================
benchmark_nsga <- function(
ticker = "NVDA",
dinero_inicial = 5800,
years_back = 7,
split_train = 0.8,
pop_grid = c(24, 36, 48, 60),
gen_grid = c(20, 30, 40, 50),
preferir_abierta = FALSE,
show_plot = FALSE,
seed = 123,
parallel = FALSE,
workers = max(1, parallel::detectCores() - 1),
retry = 2
) {
suppressPackageStartupMessages({
library(quantmod); library(dplyr); library(tidyr)
library(purrr); library(DT); library(plotly); library(scales)
})
# ---------- Descargar datos una sola vez (con reintentos) ----------
from <- Sys.Date() - round(years_back * 365); to <- Sys.Date()
datos_xts <- NULL; err_last <- NULL
for (k in 0:retry) {
datos_xts <- try(getSymbols(ticker, from = from, to = to, auto.assign = FALSE), silent = TRUE)
if (!inherits(datos_xts, "try-error")) break
err_last <- as.character(datos_xts)
Sys.sleep(1 + k)  # pequeño backoff
}
if (inherits(datos_xts, "try-error")) {
stop(paste0("No se pudo descargar datos de ", ticker, " tras ", retry + 1, " intentos.\n", err_last))
}
# ---------- Evaluador de una combinación ----------
eval_combo <- function(popsize, generations) {
set.seed(seed)
t0 <- proc.time()
out <- try(
generar_reporte_long_v2(
dinero_inicial = dinero_inicial,
ticker         = ticker,
years_back     = years_back,
split_train    = split_train,
popsize        = popsize,
generations    = generations,
preferir_abierta = preferir_abierta,
show_plot      = show_plot
),
silent = TRUE
)
elapsed <- as.numeric((proc.time() - t0)[3])
if (inherits(out, "try-error") || is.null(out)) {
return(dplyr::tibble(
ticker = ticker, popsize = popsize, generations = generations,
status = "FAIL", motivo = substr(as.character(out), 1, 160),
PnL = NA_real_, CAGR = NA_real_, Sharpe = NA_real_, MaxDD = NA_real_,
seconds = elapsed
))
}
dplyr::tibble(
ticker = ticker, popsize = popsize, generations = generations,
status = "OK", motivo = "",
PnL = as.numeric(out$ganancia),
CAGR = as.numeric(out$cagr),
Sharpe = as.numeric(out$sharpe),
MaxDD = as.numeric(out$mdd),
seconds = elapsed
)
}
# ---------- Correr la grilla (opcional en paralelo) ----------
grid <- expand.grid(popsize = pop_grid, generations = gen_grid, KEEP.OUT.ATTRS = FALSE)
if (parallel) {
if (!requireNamespace("future", quietly = TRUE) ||
!requireNamespace("furrr", quietly = TRUE)) {
warning("Paralelo requiere 'future' y 'furrr'; se usará modo secuencial.")
results <- purrr::pmap_dfr(grid, ~ eval_combo(..1, ..2))
} else {
future::plan(future::multisession, workers = workers)
on.exit(future::plan(future::sequential), add = TRUE)
results <- furrr::future_pmap_dfr(grid, ~ eval_combo(..1, ..2))
}
} else {
results <- purrr::pmap_dfr(grid, ~ eval_combo(..1, ..2))
}
results <- dplyr::arrange(results, dplyr::desc(PnL))
# ---------- Frontera eficiente (máx PnL, mín seconds) ----------
# Objetivo: maximizar PnL y minimizar seconds
is_dominated <- function(i, X) {
any(
X$seconds <= X$seconds[i] & X$PnL >= X$PnL[i] &
(X$seconds < X$seconds[i] | X$PnL > X$PnL[i]),
na.rm = TRUE
)
}
res_ok <- results %>%
dplyr::filter(status == "OK", is.finite(PnL), is.finite(seconds))
if (nrow(res_ok) > 0) {
dominated <- sapply(seq_len(nrow(res_ok)), function(i) is_dominated(i, res_ok))
res_ok$pareto <- !dominated
} else {
res_ok$pareto <- logical(0)
}
results <- results %>%
dplyr::left_join(
res_ok %>% dplyr::select(popsize, generations, pareto),
by = c("popsize","generations")
) %>%
tidyr::replace_na(list(pareto = FALSE))
# ---------- Tabla DT ----------
dt <- datatable(
results %>%
mutate(CAGR = percent(CAGR, accuracy = 0.1),
MaxDD = percent(MaxDD, accuracy = 0.1),
seconds = round(seconds, 1),
pareto = ifelse(isTRUE(pareto), "Sí", "No")),
options = list(pageLength = min(30, nrow(results)),
language = list(url='//cdn.datatables.net/plug-ins/1.10.21/i18n/Spanish.json')),
caption = paste("Benchmark", ticker, "—", nrow(results), "combinaciones")
)
# ---------- Heatmap PnL ----------
heat_df <- results %>% filter(status == "OK") %>%
mutate(popsize = factor(popsize), generations = factor(generations))
heatmap <- plot_ly(
heat_df, x = ~generations, y = ~popsize, z = ~PnL, type = "heatmap",
hovertemplate = "Gen: %{x}<br>Pop: %{y}<br>PnL: $%{z:.0f}<extra></extra>"
) %>% layout(
title = paste0(ticker, " — PnL por (popsize, generations)"),
xaxis = list(title = "Generations"),
yaxis = list(title = "Popsize")
)
# ---------- Scatter tiempo vs PnL + frontera ----------
scatter <- plot_ly(
results %>% filter(status == "OK"),
x = ~seconds, y = ~PnL, type = "scatter", mode = "markers",
size = ~pmax(Sharpe, 0), color = ~MaxDD,
text = ~paste0("popsize=", popsize, " • gen=", generations,
"<br>Sharpe=", round(Sharpe, 2),
"<br>MaxDD=", percent(MaxDD, 0.1)),
hovertemplate = "Tiempo: %{x:.1f}s<br>PnL: $%{y:.0f}<br>%{text}<extra></extra>"
) %>% layout(
title = paste0(ticker, " — PnL vs Tiempo (tamaño=Sharpe, color=MaxDD)"),
xaxis = list(title = "Segundos"),
yaxis = list(title = "PnL ($)")
)
if (any(res_ok$pareto)) {
scatter <- scatter %>%
add_trace(
data = res_ok %>% filter(pareto),
x = ~seconds, y = ~PnL, type = "scatter", mode = "markers+lines",
marker = list(symbol = "diamond-open", size = 10),
name = "Frontera eficiente",
hovertemplate = "FRONTERA<br>Tiempo: %{x:.1f}s<br>PnL: $%{y:.0f}<extra></extra>"
)
}
list(
results = results,
table   = dt,
heatmap = heatmap,
scatter = scatter,
best_by_pnl = results %>% filter(status == "OK") %>% slice_max(PnL, n = 1, with_ties = FALSE),
pareto_set = res_ok %>% filter(pareto) %>% arrange(seconds, desc(PnL))
)
}
# =====================  FIN BENCHMARK NSGA-II  ======================
bench_nvda <- benchmark_nsga(
ticker = "EL",
years_back = 7,
pop_grid = c(24,36,48,60,72),
gen_grid = c(20,30,40,50),
parallel = FALSE  # pon TRUE si tienes 'future' y 'furrr'
)
bench_nvda$table      # tabla interactiva
bench_nvda$heatmap    # heatmap PnL
bench_nvda$scatter    # scatter tiempo vs PnL con frontera
bench_nvda$best_by_pnl
bench_nvda$pareto_set
bench_nvda <- benchmark_nsga(
ticker = "VV",
years_back = 7,
pop_grid = c(24,36,48,60,72),
gen_grid = c(20,30,40,50),
parallel = FALSE  # pon TRUE si tienes 'future' y 'furrr'
)
bench_nvda$table      # tabla interactiva
bench_nvda$heatmap    # heatmap PnL
bench_nvda$scatter    # scatter tiempo vs PnL con frontera
bench_nvda$best_by_pnl
bench_nvda$pareto_set
#| echo: false
#| warning: false
#| message: false
#| results: 'hide'
# LIBRARIES & SETUP ----
# Time Series ML
library(tidymodels)
library(dplyr)
library(modeltime)
library(modeltime.ensemble)
library(readr)
library(rules)
library(httr)
library(jsonlite)
library(fredr)
library(mco)
# Timing & Parallel Processing
library(tictoc)
library(future)
library(doFuture)
# Core
library(plotly)
library(tidyverse)
library(lubridate)
library(timetk)
library(DT)
#Data
library(quantmod)
library(tibble)
# Sentiment
library(syuzhet)
library(htmltools)
library(TTR)
library(tidyr)
library(scales)
library(zoo)
source("utils_functions_optimize.R")
set.seed(123)        # ← antes de llamar a generar_reporte_long()
api_key <- "ZFXEJJ0DSF9UTSLO"    #Alphavantage
tickers <- c("EL",
"MSTR","CYN","CHX","RCKY","XBI","XOM","CRWV","TSLA","PLTR","EL","HIMS","QBTS","NVDS","BB",
"ODD","WDC","VKTX",
"GPCR","NVDA","AAPL","TQQQ",
"BBAR","WRD","SQQQ","TSLQ","PHAT",
# # Sugerencias de seguimiento extra
# # Grandes tecnológicas
"MSFT","AMZN","GOOGL","META","JPM","GS","BAC",
#
# # # Semiconductores y alta volatilidad
"AMD", "TSM",
# #
# # # Salud / biotecnología
"PFE", "MRNA",
#
# # Cripto / FinTech
"COIN",
#
# # China / internacional
"BABA",
#
# # Índices y ETFs de amplio mercado
"SPY", "QQQ",
#
# # # Apalancados alternativos
"SOXL", "SOXS",
#  # Energía / Commodities
"XOM","CVX","COP",
#
# # EV adicionales
"RIVN","NIO","LCID",
#
# # Renovables
"ENPH","SEDG","RUN",
#
# # AI / Cloud
"SNOW","OKTA","MDB",
#
# # Retail
"MCD","NKE",
#
# # Fintech / cripto extra
"HOOD","MARA"
)
popsize=36
generations=30
htmltools::tags$style(HTML("
.nav-tabs .nav-link { padding: .45rem .9rem; font-weight: 600; }
.nav-tabs { gap: .5rem; border-bottom: 1px solid #e9ecef; }
.tab-content { padding-top: .75rem; }
"))
#| echo: false
#| warning: false
#| message: false
# Mostrar resultados
### Análisis estadístico
resultados<-procesar_tickers_getsymbols(tickers)
#| echo: false
#| warning: false
#| message: false
#| results: 'hide'
# LIBRARIES & SETUP ----
# Time Series ML
library(tidymodels)
library(dplyr)
library(modeltime)
library(modeltime.ensemble)
library(readr)
library(rules)
library(httr)
library(jsonlite)
library(fredr)
library(mco)
# Timing & Parallel Processing
library(tictoc)
library(future)
library(doFuture)
# Core
library(plotly)
library(tidyverse)
library(lubridate)
library(timetk)
library(DT)
#Data
library(quantmod)
library(tibble)
# Sentiment
library(syuzhet)
library(htmltools)
library(TTR)
library(tidyr)
library(scales)
library(zoo)
source("utils_functions_optimize.R")
set.seed(123)        # ← antes de llamar a generar_reporte_long()
api_key <- "ZFXEJJ0DSF9UTSLO"    #Alphavantage
tickers <- c("EL",
"MSTR","CYN","CHX","RCKY","XBI","XOM","CRWV","TSLA","PLTR","EL","HIMS","QBTS","NVDS","BB",
"ODD","WDC","VKTX",
"GPCR","NVDA","AAPL","TQQQ",
"BBAR","WRD","SQQQ","TSLQ","PHAT",
# # Sugerencias de seguimiento extra
# # Grandes tecnológicas
"MSFT","AMZN","GOOGL","META","JPM","GS","BAC",
#
# # # Semiconductores y alta volatilidad
"AMD", "TSM",
# #
# # # Salud / biotecnología
"PFE", "MRNA",
#
# # Cripto / FinTech
"COIN",
#
# # China / internacional
"BABA",
#
# # Índices y ETFs de amplio mercado
"SPY", "QQQ",
#
# # # Apalancados alternativos
"SOXL", "SOXS",
#  # Energía / Commodities
"XOM","CVX","COP",
#
# # EV adicionales
"RIVN","NIO","LCID",
#
# # Renovables
"ENPH","SEDG","RUN",
#
# # AI / Cloud
"SNOW","OKTA","MDB",
#
# # Retail
"MCD","NKE",
#
# # Fintech / cripto extra
"HOOD","MARA"
)
popsize=36
generations=30
htmltools::tags$style(HTML("
.nav-tabs .nav-link { padding: .45rem .9rem; font-weight: 600; }
.nav-tabs { gap: .5rem; border-bottom: 1px solid #e9ecef; }
.tab-content { padding-top: .75rem; }
"))
#| echo: false
#| warning: false
#| message: false
# Mostrar resultados
### Análisis estadístico
resultados<-procesar_tickers_getsymbols(tickers)
tickers_filtrados <- resultados$data_long %>%
# Convertimos "80.0%" → 80
mutate(Prob1_num = parse_number(Prob_1)) %>%
# Filtramos los mayores a 50
filter(Prob1_num > 50) %>%
# Extraemos como vector de caracteres
pull(Accion)
tickers_filtrados
setwd("C:/Users/Cesar/OneDrive/Proyectos futuros/BI_Evolution/Web")
setwd("C:/Users/Cesar/OneDrive/Proyectos futuros/BI_Evolution/Web")
